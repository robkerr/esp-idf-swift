// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wifi_scan.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Espressif Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Espressif_WiFiScanMsgType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case typeCmdScanStart // = 0
    case typeRespScanStart // = 1
    case typeCmdScanStatus // = 2
    case typeRespScanStatus // = 3
    case typeCmdScanResult // = 4
    case typeRespScanResult // = 5
    case UNRECOGNIZED(Int)

    init() {
        self = .typeCmdScanStart
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .typeCmdScanStart
        case 1: self = .typeRespScanStart
        case 2: self = .typeCmdScanStatus
        case 3: self = .typeRespScanStatus
        case 4: self = .typeCmdScanResult
        case 5: self = .typeRespScanResult
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .typeCmdScanStart: return 0
        case .typeRespScanStart: return 1
        case .typeCmdScanStatus: return 2
        case .typeRespScanStatus: return 3
        case .typeCmdScanResult: return 4
        case .typeRespScanResult: return 5
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

    extension Espressif_WiFiScanMsgType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Espressif_WiFiScanMsgType] = [
            .typeCmdScanStart,
            .typeRespScanStart,
            .typeCmdScanStatus,
            .typeRespScanStatus,
            .typeCmdScanResult,
            .typeRespScanResult,
        ]
    }

#endif // swift(>=4.2)

struct Espressif_CmdScanStart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blocking: Bool = false

    var passive: Bool = false

    var groupChannels: UInt32 = 0

    var periodMs: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_RespScanStart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_CmdScanStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_RespScanStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scanFinished: Bool = false

    var resultCount: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_CmdScanResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startIndex: UInt32 = 0

    var count: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_WiFiScanResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ssid: Data = SwiftProtobuf.Internal.emptyData

    var channel: UInt32 = 0

    var rssi: Int32 = 0

    var bssid: Data = SwiftProtobuf.Internal.emptyData

    var auth: Espressif_WifiAuthMode = .open

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_RespScanResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entries: [Espressif_WiFiScanResult] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Espressif_WiFiScanPayload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var msg: Espressif_WiFiScanMsgType {
        get { return _storage._msg }
        set { _uniqueStorage()._msg = newValue }
    }

    var status: Espressif_Status {
        get { return _storage._status }
        set { _uniqueStorage()._status = newValue }
    }

    var payload: OneOf_Payload? {
        get { return _storage._payload }
        set { _uniqueStorage()._payload = newValue }
    }

    var cmdScanStart: Espressif_CmdScanStart {
        get {
            if case let .cmdScanStart(v)? = _storage._payload { return v }
            return Espressif_CmdScanStart()
        }
        set { _uniqueStorage()._payload = .cmdScanStart(newValue) }
    }

    var respScanStart: Espressif_RespScanStart {
        get {
            if case let .respScanStart(v)? = _storage._payload { return v }
            return Espressif_RespScanStart()
        }
        set { _uniqueStorage()._payload = .respScanStart(newValue) }
    }

    var cmdScanStatus: Espressif_CmdScanStatus {
        get {
            if case let .cmdScanStatus(v)? = _storage._payload { return v }
            return Espressif_CmdScanStatus()
        }
        set { _uniqueStorage()._payload = .cmdScanStatus(newValue) }
    }

    var respScanStatus: Espressif_RespScanStatus {
        get {
            if case let .respScanStatus(v)? = _storage._payload { return v }
            return Espressif_RespScanStatus()
        }
        set { _uniqueStorage()._payload = .respScanStatus(newValue) }
    }

    var cmdScanResult: Espressif_CmdScanResult {
        get {
            if case let .cmdScanResult(v)? = _storage._payload { return v }
            return Espressif_CmdScanResult()
        }
        set { _uniqueStorage()._payload = .cmdScanResult(newValue) }
    }

    var respScanResult: Espressif_RespScanResult {
        get {
            if case let .respScanResult(v)? = _storage._payload { return v }
            return Espressif_RespScanResult()
        }
        set { _uniqueStorage()._payload = .respScanResult(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Payload: Equatable {
        case cmdScanStart(Espressif_CmdScanStart)
        case respScanStart(Espressif_RespScanStart)
        case cmdScanStatus(Espressif_CmdScanStatus)
        case respScanStatus(Espressif_RespScanStatus)
        case cmdScanResult(Espressif_CmdScanResult)
        case respScanResult(Espressif_RespScanResult)

        #if !swift(>=4.1)
            static func == (lhs: Espressif_WiFiScanPayload.OneOf_Payload, rhs: Espressif_WiFiScanPayload.OneOf_Payload) -> Bool {
                switch (lhs, rhs) {
                case let (.cmdScanStart(l), .cmdScanStart(r)): return l == r
                case let (.respScanStart(l), .respScanStart(r)): return l == r
                case let (.cmdScanStatus(l), .cmdScanStatus(r)): return l == r
                case let (.respScanStatus(l), .respScanStatus(r)): return l == r
                case let (.cmdScanResult(l), .cmdScanResult(r)): return l == r
                case let (.respScanResult(l), .respScanResult(r)): return l == r
                default: return false
                }
            }
        #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "espressif"

extension Espressif_WiFiScanMsgType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "TypeCmdScanStart"),
        1: .same(proto: "TypeRespScanStart"),
        2: .same(proto: "TypeCmdScanStatus"),
        3: .same(proto: "TypeRespScanStatus"),
        4: .same(proto: "TypeCmdScanResult"),
        5: .same(proto: "TypeRespScanResult"),
    ]
}

extension Espressif_CmdScanStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CmdScanStart"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blocking"),
        2: .same(proto: "passive"),
        3: .standard(proto: "group_channels"),
        4: .standard(proto: "period_ms"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &blocking)
            case 2: try decoder.decodeSingularBoolField(value: &passive)
            case 3: try decoder.decodeSingularUInt32Field(value: &groupChannels)
            case 4: try decoder.decodeSingularUInt32Field(value: &periodMs)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if blocking != false {
            try visitor.visitSingularBoolField(value: blocking, fieldNumber: 1)
        }
        if passive != false {
            try visitor.visitSingularBoolField(value: passive, fieldNumber: 2)
        }
        if groupChannels != 0 {
            try visitor.visitSingularUInt32Field(value: groupChannels, fieldNumber: 3)
        }
        if periodMs != 0 {
            try visitor.visitSingularUInt32Field(value: periodMs, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_CmdScanStart, rhs: Espressif_CmdScanStart) -> Bool {
        if lhs.blocking != rhs.blocking { return false }
        if lhs.passive != rhs.passive { return false }
        if lhs.groupChannels != rhs.groupChannels { return false }
        if lhs.periodMs != rhs.periodMs { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_RespScanStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RespScanStart"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_RespScanStart, rhs: Espressif_RespScanStart) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_CmdScanStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CmdScanStatus"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_CmdScanStatus, rhs: Espressif_CmdScanStatus) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_RespScanStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RespScanStatus"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "scan_finished"),
        2: .standard(proto: "result_count"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &scanFinished)
            case 2: try decoder.decodeSingularUInt32Field(value: &resultCount)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if scanFinished != false {
            try visitor.visitSingularBoolField(value: scanFinished, fieldNumber: 1)
        }
        if resultCount != 0 {
            try visitor.visitSingularUInt32Field(value: resultCount, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_RespScanStatus, rhs: Espressif_RespScanStatus) -> Bool {
        if lhs.scanFinished != rhs.scanFinished { return false }
        if lhs.resultCount != rhs.resultCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_CmdScanResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CmdScanResult"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "start_index"),
        2: .same(proto: "count"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &startIndex)
            case 2: try decoder.decodeSingularUInt32Field(value: &count)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if startIndex != 0 {
            try visitor.visitSingularUInt32Field(value: startIndex, fieldNumber: 1)
        }
        if count != 0 {
            try visitor.visitSingularUInt32Field(value: count, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_CmdScanResult, rhs: Espressif_CmdScanResult) -> Bool {
        if lhs.startIndex != rhs.startIndex { return false }
        if lhs.count != rhs.count { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_WiFiScanResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WiFiScanResult"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ssid"),
        2: .same(proto: "channel"),
        3: .same(proto: "rssi"),
        4: .same(proto: "bssid"),
        5: .same(proto: "auth"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ssid)
            case 2: try decoder.decodeSingularUInt32Field(value: &channel)
            case 3: try decoder.decodeSingularInt32Field(value: &rssi)
            case 4: try decoder.decodeSingularBytesField(value: &bssid)
            case 5: try decoder.decodeSingularEnumField(value: &auth)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !ssid.isEmpty {
            try visitor.visitSingularBytesField(value: ssid, fieldNumber: 1)
        }
        if channel != 0 {
            try visitor.visitSingularUInt32Field(value: channel, fieldNumber: 2)
        }
        if rssi != 0 {
            try visitor.visitSingularInt32Field(value: rssi, fieldNumber: 3)
        }
        if !bssid.isEmpty {
            try visitor.visitSingularBytesField(value: bssid, fieldNumber: 4)
        }
        if auth != .open {
            try visitor.visitSingularEnumField(value: auth, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_WiFiScanResult, rhs: Espressif_WiFiScanResult) -> Bool {
        if lhs.ssid != rhs.ssid { return false }
        if lhs.channel != rhs.channel { return false }
        if lhs.rssi != rhs.rssi { return false }
        if lhs.bssid != rhs.bssid { return false }
        if lhs.auth != rhs.auth { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_RespScanResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RespScanResult"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entries"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &entries)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !entries.isEmpty {
            try visitor.visitRepeatedMessageField(value: entries, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_RespScanResult, rhs: Espressif_RespScanResult) -> Bool {
        if lhs.entries != rhs.entries { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Espressif_WiFiScanPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".WiFiScanPayload"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "msg"),
        2: .same(proto: "status"),
        10: .standard(proto: "cmd_scan_start"),
        11: .standard(proto: "resp_scan_start"),
        12: .standard(proto: "cmd_scan_status"),
        13: .standard(proto: "resp_scan_status"),
        14: .standard(proto: "cmd_scan_result"),
        15: .standard(proto: "resp_scan_result"),
    ]

    fileprivate class _StorageClass {
        var _msg: Espressif_WiFiScanMsgType = .typeCmdScanStart
        var _status: Espressif_Status = .success
        var _payload: Espressif_WiFiScanPayload.OneOf_Payload?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _msg = source._msg
            _status = source._status
            _payload = source._payload
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                switch fieldNumber {
                case 1: try decoder.decodeSingularEnumField(value: &_storage._msg)
                case 2: try decoder.decodeSingularEnumField(value: &_storage._status)
                case 10:
                    var v: Espressif_CmdScanStart?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .cmdScanStart(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .cmdScanStart(v) }
                case 11:
                    var v: Espressif_RespScanStart?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .respScanStart(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .respScanStart(v) }
                case 12:
                    var v: Espressif_CmdScanStatus?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .cmdScanStatus(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .cmdScanStatus(v) }
                case 13:
                    var v: Espressif_RespScanStatus?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .respScanStatus(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .respScanStatus(v) }
                case 14:
                    var v: Espressif_CmdScanResult?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .cmdScanResult(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .cmdScanResult(v) }
                case 15:
                    var v: Espressif_RespScanResult?
                    if let current = _storage._payload {
                        try decoder.handleConflictingOneOf()
                        if case let .respScanResult(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v { _storage._payload = .respScanResult(v) }
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if _storage._msg != .typeCmdScanStart {
                try visitor.visitSingularEnumField(value: _storage._msg, fieldNumber: 1)
            }
            if _storage._status != .success {
                try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 2)
            }
            switch _storage._payload {
            case let .cmdScanStart(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            case let .respScanStart(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            case let .cmdScanStatus(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            case let .respScanStatus(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            case let .cmdScanResult(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            case let .respScanResult(v)?:
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            case nil: break
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Espressif_WiFiScanPayload, rhs: Espressif_WiFiScanPayload) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._msg != rhs_storage._msg { return false }
                if _storage._status != rhs_storage._status { return false }
                if _storage._payload != rhs_storage._payload { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
